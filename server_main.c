#include <stdio.h>
#include <signal.h>
#include <string.h>
#include <pthread.h>

#include <libwebsockets.h>


static void log_emit_function(int level, const char *line) {
    printf("%s\n", line);
}


struct per_session_data {
    struct per_session_data *pss_list;
    struct lws *wsi;
    uint32_t tail;
    int subscribeAckPending;
};


static int sendCounter = 0;
static int recvCounter = 0;
static char* sendBuffer = NULL;

uint8_t ackMessage[] = {
        0x0c, 0x00, 0x00, 0x00, 0x08, 0x00, 0x0c, 0x00, 0x08, 0x00, 0x04, 0x00, 0x08, 0x00, 0x00,
        0x00, 0x08, 0x00, 0x00, 0x00, 0xf0, 0x01, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x18, 0x01,
        0x00, 0x00, 0xd0, 0x00, 0x00, 0x00, 0x88, 0x00, 0x00, 0x00, 0x5c, 0x00, 0x00, 0x00, 0x30,
        0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x1e, 0xff, 0xff, 0xff, 0x00, 0x00, 0x3c, 0x00,
        0x1e, 0x00, 0xd0, 0x07, 0x1c, 0x01, 0x00, 0x00, 0x2c, 0x01, 0x00, 0x00, 0x3c, 0x01, 0x00,
        0x00, 0x60, 0x01, 0x00, 0x00, 0x78, 0x01, 0x00, 0x00, 0x8c, 0x01, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x06, 0x46, 0xff, 0xff, 0xff, 0x00, 0x00, 0x3c, 0x00, 0x1e, 0x00, 0xd0, 0x07, 0xf4,
        0x00, 0x00, 0x00, 0x04, 0x01, 0x00, 0x00, 0x14, 0x01, 0x00, 0x00, 0x38, 0x01, 0x00, 0x00,
        0x50, 0x01, 0x00, 0x00, 0x64, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x6e, 0xff, 0xff,
        0xff, 0x00, 0x00, 0x3c, 0x00, 0x1e, 0x00, 0xd0, 0x07, 0xcc, 0x00, 0x00, 0x00, 0xdc, 0x00,
        0x00, 0x00, 0xec, 0x00, 0x00, 0x00, 0x10, 0x01, 0x00, 0x00, 0x28, 0x01, 0x00, 0x00, 0x3c,
        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xda, 0xff, 0xff, 0xff, 0x00, 0x00, 0x3c, 0x00,
        0x1e, 0x00, 0xd0, 0x07, 0xa4, 0x00, 0x00, 0x00, 0xb4, 0x00, 0x00, 0x00, 0xc4, 0x00, 0x00,
        0x00, 0xe8, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x14, 0x01, 0x00, 0x00, 0x00, 0x03,
        0x1e, 0x00, 0x26, 0x00, 0x00, 0x00, 0x25, 0x00, 0x20, 0x00, 0x1c, 0x00, 0x18, 0x00, 0x14,
        0x00, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x08, 0x00, 0x06, 0x00,
        0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x1e, 0x00, 0xd0, 0x07, 0x60, 0x00, 0x00,
        0x00, 0x70, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0xa4, 0x00, 0x00, 0x00, 0xbc, 0x00, 0x00, 0x00, 0xd0,
        0x00, 0x00, 0x00, 0x00, 0x02, 0x1e, 0x00, 0x28, 0x00, 0x00, 0x00, 0x27, 0x00, 0x20, 0x00, 0x1c, 0x00, 0x18,
        0x00, 0x14, 0x00, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x08, 0x00, 0x06, 0x00, 0x1e,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x1e, 0x00, 0xd0, 0x07, 0x1c, 0x00, 0x00, 0x00, 0x2c, 0x00, 0x00,
        0x00, 0x3c, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 0x00, 0x8c, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x01, 0x0e, 0x00, 0x00, 0x00, 0x47, 0x41, 0x56, 0x20, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f,
        0x6e, 0x20, 0x32, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x47, 0x41, 0x56, 0x20, 0x70, 0x6f, 0x73, 0x69, 0x74,
        0x69, 0x6f, 0x6e, 0x20, 0x31, 0x00, 0x00, 0x22, 0x00, 0x00, 0x00, 0x49, 0x6e, 0x6a, 0x65, 0x63, 0x74, 0x69,
        0x6f, 0x6e, 0x20, 0x71, 0x75, 0x61, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x20, 0x70, 0x69, 0x73, 0x74, 0x6f, 0x6e,
        0x20, 0x66, 0x65, 0x65, 0x64, 0x62, 0x61, 0x63, 0x6b, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x45, 0x78, 0x68,
        0x61, 0x75, 0x73, 0x74, 0x20, 0x76, 0x61, 0x6c, 0x76, 0x65, 0x20, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f,
        0x6e, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x43, 0x79, 0x6c, 0x69, 0x6e, 0x64, 0x65, 0x72, 0x20, 0x70, 0x72,
        0x65, 0x73, 0x73, 0x75, 0x72, 0x65, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x43, 0x72, 0x61, 0x6e, 0x6b,
        0x20, 0x61, 0x6e, 0x67, 0x6c, 0x65, 0x00, 0x00, 0x00, 0x12, 0x00, 0x18, 0x00, 0x14, 0x00, 0x13, 0x00, 0x10,
        0x00, 0x0e, 0x00, 0x0c, 0x00, 0x0a, 0x00, 0x04, 0x00, 0x12, 0x00, 0x00, 0x00, 0x92, 0x10, 0x00, 0x00, 0x00,
        0x00, 0xdc, 0x05, 0x88, 0x13, 0xdc, 0x05, 0x98, 0x03, 0x00, 0x06, 0x04, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00,
        0x00, 0x31, 0x32, 0x58, 0x39, 0x32, 0x44, 0x46, 0x00
};


static int callback_minimal(struct lws *wsi, enum lws_callback_reasons reason, void *user, void *in, size_t len) {

    struct per_session_data *session_data = (struct per_session_data*) user;

    switch (reason) {

        case LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED:
            printf("%s(%d) callback_minimal(reason: LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED) not implemented for %p\n", __FILE__, __LINE__, wsi);
            break;

        case LWS_CALLBACK_WSI_CREATE:
            printf("%s(%d) callback_minimal(reason: LWS_CALLBACK_WSI_CREATE) not implemented for %p\n", __FILE__, __LINE__, wsi);
            break;

        case LWS_CALLBACK_WSI_DESTROY:
            printf("%s(%d) callback_minimal(reason: LWS_CALLBACK_WSI_DESTROY) not implemented for %p\n", __FILE__, __LINE__, wsi);
            break;

        case LWS_CALLBACK_PROTOCOL_INIT:
            printf("%s(%d) callback_minimal(reason: LWS_CALLBACK_PROTOCOL_INIT) not implemented for %p\n", __FILE__, __LINE__, wsi);
            break;

        case LWS_CALLBACK_EVENT_WAIT_CANCELLED:
            printf("%s(%d) callback_minimal(reason: LWS_CALLBACK_EVENT_WAIT_CANCELLED) not implemented for %p\n", __FILE__, __LINE__, wsi);
            break;

        case LWS_CALLBACK_HTTP_CONFIRM_UPGRADE:
            printf("%s(%d) callback_minimal(reason: LWS_CALLBACK_HTTP_CONFIRM_UPGRADE) not implemented for %p\n", __FILE__, __LINE__, wsi);
            break;

        case LWS_CALLBACK_HTTP_BIND_PROTOCOL:
            printf("%s(%d) callback_minimal(reason: LWS_CALLBACK_HTTP_BIND_PROTOCOL) not implemented for %p\n", __FILE__, __LINE__, wsi);
            break;

        case LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION:
            printf("%s(%d) callback_minimal(reason: LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION) not implemented for %p\n", __FILE__, __LINE__, wsi);
            break;

        case LWS_CALLBACK_ADD_HEADERS:
            printf("%s(%d) callback_minimal(reason: LWS_CALLBACK_ADD_HEADERS) not implemented for %p\n", __FILE__, __LINE__, wsi);
            break;

        case LWS_CALLBACK_SERVER_WRITEABLE:
            printf("%s(%d) callback_minimal(reason: LWS_CALLBACK_SERVER_WRITEABLE) sending for %p\n", __FILE__, __LINE__, wsi);

            if (session_data->subscribeAckPending) {
                // free previous send buffer
                free(sendBuffer);

                // create and fill new send buffer
                sendBuffer = malloc(LWS_PRE + sizeof(ackMessage));
                memcpy(sendBuffer+LWS_PRE, ackMessage, sizeof(ackMessage));
                lws_write(wsi, ((unsigned char*)sendBuffer)+LWS_PRE, sizeof(ackMessage), LWS_WRITE_BINARY);

                ++sendCounter;
                session_data->subscribeAckPending = 0;
            }

            break;

        case LWS_CALLBACK_RECEIVE:
            printf("%s(%d) callback_minimal(reason: LWS_CALLBACK_RECEIVE) for %p with length %lu\n", __FILE__, __LINE__, wsi, len);
            uint8_t* text = (uint8_t*) in;
            while(len--) {
                printf("%02x ", *text);
                ++text;
            }
            printf("\n");
            ++recvCounter;
            session_data->subscribeAckPending = 1;
            printf("%s(%d) calling lws_callback_on_writable\n", __FILE__, __LINE__);
            lws_callback_on_writable(wsi);
            printf("%s(%d) called lws_callback_on_writable\n", __FILE__, __LINE__);
            break;

        case LWS_CALLBACK_WS_SERVER_DROP_PROTOCOL:
            printf("%s(%d) callback_minimal(reason: LWS_CALLBACK_WS_SERVER_DROP_PROTOCOL) not implemented for %p\n", __FILE__, __LINE__, wsi);
            break;

        case 0:
        case 4:
        default:
            printf("%s(%d) callback_minimal(reason: %d) not implemented\n", __FILE__, __LINE__, reason);
    }

    return 0;
}

int main(int argc, char **argv) {

    pthread_t pt_id = pthread_self();
    printf("%s(%d) [%lu] %s starting\n", __FILE__, __LINE__, pt_id, __func__);

    // configure logging
    lws_set_log_level(LLL_USER | LLL_ERR | LLL_WARN | LLL_NOTICE, log_emit_function);
    lwsl_user("server started");

    // specify protocols
    struct lws_protocols protocols[] = {
            { "lws-minimal-proxy", callback_minimal, sizeof(struct per_session_data), 128, 0, NULL, 0 },
            { NULL, NULL, 0, 0 } /* terminator */
    };

    // specify context
    struct lws_context_creation_info info;
    memset(&info, 0, sizeof info);
    info.port = 8765;  // server listens to http port
    info.protocols = protocols;
    info.foreign_loops = NULL;  // can point to sd_loop later
    info.options |= LWS_SERVER_OPTION_SDEVENT;

    // create context
    struct lws_context *context;
    context = lws_create_context(&info);
    if (!context) {
        lwsl_err("lws init failed\n");
        return 1;
    }

    // run
    int n=0;
    while (n >= 0) {
        n = lws_service(context, 0);
    }

    // cleanup
    lws_context_destroy(context);

	return 0;
}
